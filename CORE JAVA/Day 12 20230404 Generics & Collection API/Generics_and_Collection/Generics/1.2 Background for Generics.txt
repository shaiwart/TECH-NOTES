I. The Era Before Java 5 (The Problem)
================================================================================

Before Generics (Java 5), classes designed to hold any type of object had to use `Object` checks and explicit casting. This lacked type safety.

Class Definition:
-----------------
public class StorageClass {
	private Object ref;

	public void store(Object ref) {
		this.ref = ref;
	}

	public Object get() {
		return ref;
	}
}

Usage:
------
StorageClass s = new StorageClass();
s.store(new Integer(100));

// We must manually cast the return type
Integer ref1 = (Integer) s.get();
System.out.println(ref1);


The Risk: ClassCastException
--------------------------------------------------------------------------------
What if we forget what type of data we stored?

// 1. We store a String
s.store("hello");

// 2. Later, we mistakenly think it's an Integer and try to cast it
Integer ref1 = (Integer) s.get();

Result:
- The compiler DOES NOT catch this error. strict syntax is correct (casting Object to Integer).
- At Runtime, the program crashes with `ClassCastException` because "hello" (String) cannot be cast to Integer.
- This makes the code unsafe and error-prone.


II. Java 5 and Later (The Solution: Generics)
================================================================================

Java 5 introduced **Generics**, which allows classes to be parameterized by type. This shifts type checking from Runtime to Compile-time. ⭐️⭐️⭐️

Generic Class Definition:
-------------------------
// 'T' is a placeholder for the Type
public class StorageClass<T> {
	private T ref;

	public void store(T ref) {
		this.ref = ref;
	}

	public T get() {
		return ref;
	}
}

Usage (Type Safety):
--------------------
// We strictly define that 's' can ONLY hold Integers
StorageClass<Integer> s = new StorageClass<Integer>();

1. Type Safety (Compile-time check):
   s.store(100);       // ✅ Allowed
   // s.store("hello"); // ❌ Compilation Error! The compiler prevents this mistake immediately.

2. No Explicit Casting:
   // The compiler knows 'get()' returns an Integer because T was replaced by Integer.
   Integer ref1 = s.get();  // ✅ No typecasting needed
   // String ref2 = s.get(); // ❌ Compilation Error!

GENERICS: Comprehensive Guide
================================================================================

1. Evolution of Collections (Java 1.4 vs Java 5)
================================================================================
Before Java 5 (Java 1.4):
	List mylist = new ArrayList(); // Untyped, holds Objects

From Java 5 Onwards:
	List<Object> mylist = new ArrayList<Object>(); // Explicitly typed

Generics Safety:
	Generics provide safety at the COMPILER level.
	
	List<String> mylist = new ArrayList<String>();
	mylist.add(30);  // ❌ Compilation Error: Ensures type safety immediately.


2. Mixing Generic and Non-generic Collections
================================================================================
You can mix them, but it is RISKY.

Safe Example:
	List<Integer> m = new ArrayList<Integer>();
	m.add(20);
	
	// Passing generic list to a raw type method works
	void disp(List mylist) { ... } 

Risky Example (Heap Pollution):
	void disp(List mylist) {
		mylist.add("hello"); // ⚠️ Adding String to what is actually a List<Integer>
	}
	
	public static void main(String args[]) {
		List<Integer> m = new ArrayList<Integer>();
		disp(m); // The method adds "hello" silently
		
		// RUNTIME ERROR!
		// The list 'm' now contains a String, but we think it's all Integers.
		Integer ob = m.get(0); // ClassCastException here!
	}
	
	LESSON: The compiler produces uncheck warnings when mixing raw and generic types for a reason.


3. Polymorphism and Generics
================================================================================
Polymorphism applies to the BASE type only (the collection class), NOT the generic parameter.

Rule: 
Generic type of reference and generic type of the object must be IDENTICAL.

	List<Parent> list = new ArrayList<Child>(); // ❌ ERROR

Reasoning (Why is this forbidden?):
	If we allowed: List<Animal> animals = new ArrayList<Dog>();
	Then we could legally do: animals.add(new Cat());
	BUT the underlying list is an ArrayList<Dog>! Putting a Cat in a Dog list breaks type safety.
	So, to prevent this "Corruption", Java forbids assigning List<Dog> to List<Animal>.

Array Exception (Arrays are different):
	Animal[] animals = new Dog[2]; // ✅ Allowed (Covariant)
	animals[0] = new Cat(); // ❌ Runtime Error: ArrayStoreException
	
	Arrays enforce types at RUNTIME.
	Generics enforce types at COMPILE TIME (Type Erasure means no runtime checks).
	Therefore, Generics must be stricter at compile time.


4. Wildcards: Safe Polymorphism
================================================================================
If we just want to READ from a collection, not add to it, we can use Wildcards.

A. Unbounded Wildcard: List<?>
--------------------------------------------------
Means "List of unknown type".
	public void disp(List<?> arr) {
		// You can READ (as Object)
		// You CANNOT ADD anything (except null)
	}

B. Upper Bounded Wildcard: List<? extends Animal>
--------------------------------------------------
Means "List of Animal or any subclass of Animal".
	public void disp(List<? extends Animal> arr) {
		for(Animal a : arr) { a.eat(); } // ✅ Safe to read as Animal
		// arr.add(new Dog()); // ❌ Cannot ADD. We don't know if it's List<Dog> or List<Cat>.
	}

C. Lower Bounded Wildcard: List<? super Dog>
--------------------------------------------------
Means "List of Dog or any superclass of Dog" (e.g., List<Dog>, List<Animal>, List<Object>).
This is the ONLY way to be able to ADD to a generic collection polymorphically.
	public void disp(List<? super Dog> arr) {
		arr.add(new Dog()); // ✅ Safe. Whatever 'arr' is, it can definitely hold a Dog.
		// arr.add(new Animal()); // ❌ Not safe. 'arr' might be List<Dog>.
	}


5. Summary of Wildcard Validity
================================================================================
1) List<?> list = new ArrayList<Dog>();              // ✅ Valid
2) List<? extends Animal> list = new ArrayList<Dog>(); // ✅ Valid
3) List<?> list = new ArrayList<? extends Animal>(); // ❌ Invalid (Cannot create object with wildcard)
4) List<? extends Dog> list = new ArrayList<Integer>(); // ❌ Invalid (Integer doesn't extend Dog)
5) List<? super Dog> list = new ArrayList<Animal>();   // ✅ Valid
6) List<? super Animal> list = new ArrayList<Dog>();   // ❌ Invalid (Dog is not super of Animal)


6. Creating Custom Generic Classes
================================================================================
class Gen<A, B> {
	A a;
	B b;
	
	Gen(A a, B b) {
		this.a = a;
		this.b = b;
	}
	
	A giveA() { return a; }
	B giveB() { return b; }
}

Usage:
	Gen<Integer, Float> g = new Gen<Integer, Float>(20, 5.6f);


7. Creating Generic Methods
================================================================================
You can define generic parameters just for a single method.

class MyClass {
	// Generic method accepting any type T
	<T> void accept(T t) {
		System.out.println(t);
	}
	
	// Generic method accepting only subtypes of 'a'
	public <T extends a> void disp(T t) {
		System.out.println(t);
	}
}

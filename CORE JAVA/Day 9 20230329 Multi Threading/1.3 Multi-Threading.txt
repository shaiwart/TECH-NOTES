		Multi-Threading

		Multi-tasking

What is multi-tasking: performing more than one task simultaneously.

a) Process-based multi-tasking
b) Thread-based multi-tasking

Process - is a program in execution.
Thread - is one of the parts of a program in execution.

1. Process-based multitasking: more than one process is running simultaneously.
   e.g. Word and Excel applications are running simultaneously.

2. Thread-based multitasking: more than one thread is running simultaneously.
   e.g. within a Word application, spell check, editing, cloud sync etc. all are running at the same time.

Whether process-based or thread-based, a CPU can handle only one task at a time, unless it is a multiprocessor machine. It is just an impression given to the user. What actually CPU does is context switching, i.e. jump from one task to another and vice-versa.


Process-based vs Thread-based

a) Threads can share the memory, processes can not.
b) Context switching between threads is relatively cheaper as compared to that between processes.
c) Cost of communication between threads is also low.

(Cheaper or low cost -> actually means less no. of system resources are used.)

Java supports thread-based multitasking.

Application of multi-threading in Java: due to multithreading feature, Java has become effective on server side. e.g. Servlet, JSP etc.

Thread-Scheduler
a) Pre-emptive: Priority based. Higher priority thread gets chance first.
b) Time-slice: Round-Robin. Fixed time is allocated to each thread for fairness.

JVM can have any scheduler, i.e. either pre-emptive or time-slice.
It is because JVM is different for different platforms.

Java has given certain mechanisms (functions) whereby you can make sure, your multi-threading application can run more or less same on any OS.


Following are the imp. steps required for multithreading application.
1) Create thread/s
2) Define thread execution body - task which is to be preformed by the thread. basically we are defining run()
3) Register thread with the thread scheduler - done by programmer.
4) Thread scheduler will execute the thread/s - done by thread scheduler.


Java's multi-threading support lies in

a) java.lang.Thread
b) java.lang.Runnable (interface)
c) java.lang.Object


Thread class: this is the most imp. class required in order to create multi-threading application.
Following are its methods.

a) start
	is used to register thread with JVM scheduler

b) run
	is used by the programmer to define thread execution body, but will be called by JVM scheduler whenever it executes a particular thread.
	when the run method is over, thread is dead.

c) sleep   (static)
	- is used to make thread sleep for some time.
	- other threads will be working.

d) setName
	to set the name of thread

e) getName
	to get the name of thread

f) currentThread
	returns the currently running thread

g) setPriority
	to set the priority
	in Java priorities are numbers from 1 to 10
	1 - minimum priority
	5 - normal priority
	10 - maximum priority

	by default every thread created has normal priority.

	(imp: priorities are not guaranteed across different platforms.)

h) getPriority
	to get the priority

i) join
	join() method is used for waiting the thread in execution until the thread on which join is called is not completed.

	Example:
	Thread t1 = new Thread(() -> {
		// imagine t1 doing a long task, e.g. downloading a file
		System.out.println("t1 started work...");
	});
	t1.start();

	t1.join();
	// The current thread (e.g., main) will PAUSE (STOP) here.
	// It waits for t1 to complete its download.
	// Only when t1 is dead/finished, main resumes.

Runnable interface: interface which contains abstract method

 void run();


âœ… There are two ways to create multi-threading application.

1) extends Thread
2) implements Runnable


e.g.
extends Thread

class Th1 extends Thread
{
	public void run()
	{
		for(int i=0; i<5; i++)
		{
			System.out.println("Hello" + i);
		}
	}
}

public class Test
{
	public static void main(String args[])
	{
		Th1 t1 = new Th1();
		t1.start();
	}
}

By default every Java application has main thread created by JVM. This thread is used to execute main() function.
In the above code, there are 2 threads:
1. main thread
2. user defined thread i.e. t1

Hence there are 2 call stacks in the above code. One for main() and other for t1 (run() method).

When main function is over, main thread dies, but user defined thread/s can continue. They will be taken care by JVM.
i.e. in the above code, after "t1.start()" when main() function is over, main thread dies, but t1's execution will be managed by JVM.


class Th2 extends Thread
{
	public void run()
	{
		System.out.println(Thread.currentThread());
		for(int i=0; i<5; i++)
		{
			System.out.println("Hello" + i);
		}
	}
}

class Test2
{
	public static void main(String args[])
	{
		System.out.println(Thread.currentThread());
		Th2 t1 = new Th2();
		t1.setName("first");
		t1.start();
	}
}


Can we call run() directly?

class Th3 extends Thread
{
	public void run()
	{
		for(int i=0; i<5; i++)
		{
			System.out.println("Hello" + i);
		}
	}
}

class Test3
{
	public static void main(String args[])
	{
		Th3 t1 = new Th3();
		t1.setName("first");
		t1.run(); // here we are calling the method directly. instead of t1.start()
	}
}

We can call run() directly. But in that case it won't be thread execution, it is a normal method call. That is different call stacks won't be created.

More than one user defined-threads
----------------------------------

class Th4 extends Thread
{
	public void run()
	{
		System.out.println(Thread.currentThread());
		for(int i=0; i<5; i++)
		{
			System.out.println("Hello" + i);
		}
	}
}

class Test4
{
	public static void main(String args[])
	{
		System.out.println(Thread.currentThread());
		Th4 t1 = new Th4();
		Th4 t2 = new Th4();
		t1.setName("first");
		t2.setName("second");
		t1.start();
		t2.start();
	}
}



class Th4_a extends Thread
{
	public void run()
	{
		for(int i=0; i<5; i++)
		{
			System.out.println("Hello  " + Thread.currentThread().getName() + "\t" + i);
			try
			{
				Thread.sleep(100);
			}
			catch(InterruptedException ie)
			{
				ie.printStackTrace();
			}
		}
	}
}

class Test4_a
{
	public static void main(String args[])
	{
		Th4_a t1 = new Th4_a();
		Th4_a t2 = new Th4_a();
		t1.setName("first");
		t2.setName("second");
		t1.start();
		t2.start();
	}
}

Explanation:
- Both threads (t1 and t2) will execute the run() method simultaneously.
- Since the loop is "for(int i=0; i<5; i++)", each thread will execute the loop 5 times.
- Total 10 lines will be printed (5 by 'first' and 5 by 'second').
- Due to 'Thread.sleep(100)', the threads will yield control, allowing them to interleave (mix) in the output.

Sample Output (Order may vary):
Hello  first	0
Hello  second	0
Hello  first	1
Hello  second	1
Hello  first	2
Hello  second	2
Hello  first	3
Hello  second	3
Hello  first	4
Hello  second	4


Implements Runnable interface
===============================
class Th5 implements Runnable
{
	public void run()
	{
		for(int i=0; i<5; i++)
		{
			System.out.println("Hello" + i);
		}
	}
}

class Test5
{
	public static void main(String args[])
	{
		Th5 ob = new Th5();
		Thread t1 = new Thread(ob);
		Thread t2 = new Thread(ob);
		t1.start();
		t2.start();
	}
}

STEPS TO CREATE THREAD USING Runnable
======================================

a) Define a class which implements Runnable
b) Define run()
c) Instantiate the class which impl. Runnable
d) Instantiate Thread class by passing above instance (child of Runnable)
e) Register Thread class instance/s


Revise "extends Thread" and "implements Runnable"

How Thread class is related to Runnable interface?

Ans- Thread class implements Runnable


Difference between extends Thread and implements Runnable
==========================================================

What is the use of implements Runnable?
	If your class is already extending some class, you can't say extends Thread, because multiple inheritance is not allowed in Java. In that case you have to go for implements Runnable.


RACE CONDITION
===============
The above program also proves that threads can share the memory.

When threads share the memory there is a risk of "race condition".

e.g.
	There are 2 threads.
	One thread is reading from a file
	Other thread is writing to a file.

Race condition means
	while one thread is reading from a file, other thread might write in a file or vice-versa.
Race condition always leads to Data Corruption.

How do we avoid Race condition?
	We will have to make sure that while one thread is working on a data, other thread should not run. Only after first thread completes its job, other thread should start its execution. In Java we can achieve this by using "synchronization".

	"synchronization" is a solution to the race condition.


public class Th6 implements Runnable
{
	synchronized public void run()
	{
		for(int i=0; i<5; i++)
		{
			System.out.println("Hello" + i);
		}
	}
	public static void main(String args[])
	{
		Th6 ob = new Th6();
		Thread t1 = new Thread(ob);
		Thread t2 = new Thread(ob);
		t1.start();
		t2.start();
	}
}




public class Th7 implements Runnable
{
	public void run()
	{
		synchronized(this)
		{
			for(int i=0; i<5; i++)
			{
				System.out.println("Hello" + i);
			}
		}
	}
	public static void main(String args[])
	{
		Th7 ob = new Th7();
		Thread t1 = new Thread(ob);
		Thread t2 = new Thread(ob);
		t1.start();
		t2.start();
	}
}


synchronized keyword
	method :- all the statements are protected.

	block :- only those statements are protected which are given inside synchronized block.



What exactly happens when we use synchronized keyword?

There is a concept of object lock.

In Java every object has a lock. This lock can be accessed by only one thread at a time. The lock will be released as soon as the thread completes its job and thus another thread can acquire the lock.
	This lock comes into picture only when object has got non-static synchronized method/s or block.
Whichever thread executes the synchronized method first, it acquires the lock. Other thread/s have to be in "seeking lock state".

Acquiring and Releasing lock happens automatically.


Once a thread acquires a lock on an object, it can have control on all the non-static synchronized methods of that object.




public class Th8 implements Runnable
{
	public void run()
	{
		synchronized(this)
		{
			for(int i=0; i<5; i++)
			{
				System.out.println("Hello" + i);
			}
		}
	}
	public static void main(String args[])
	{
		Th8 ob = new Th8();
		Th8 ob1 = new Th8();
		Thread t1 = new Thread(ob);
		Thread t2 = new Thread(ob1);
		t1.start();
		t2.start();
	}
}


Even though synchronized method or block is used to avoid "Race Condition", there can be danger of "DeadLock" inside it.
e.g. if one thread is working inside synchronized block or method and if it gets stuck up! Imagine what will happen?
Neither this thread can complete and release the lock, nor other thread can acquire the lock.

Solution to this is to have a Communication bet'n threads.
i.e. if the thread realizes it can not continue, it should come out of synchronized method or block and release the lock. Now other thread will acquire the lock, execute the code and allow the first thread to resume.

Following are the methods used for communication bet'n threads.

a) wait
	it will make thread, release the lock and go to wait pool.

b) notify
	it will make the thread to move from wait pool to seeking lock state.

c) notifyAll
	it will make all the threads to move from wait pool to seeking lock state.

These methods are defined in "java.lang.Object" class and are final so u can not override them.

These methods must be called from synchronized method or block.

Difference bet'n wait and sleep

		wait releases the lock on an object, sleep does not.



Thread-safety

Thread-safe classes are those classes, which contain synchronized non-static methods.


What is class lock?

Every class has a lock. It is actually a lock on an instance of class Class. This is because, whenever any class is loaded in Java, it is represented by instance of class Class.
The class lock comes into picture in case of synchronized static methods.
Thread which gives a call to synchronized static method can acquire a class lock. Only after thread complete that static method, lock is released.


public class Th9 implements Runnable
{
	public void run()
	{
		synchronized(this)
		{
			for(int i=0; i<5; i++)
			{
				System.out.println("Hello" + i);
			}
		}
	}
	public static void main(String args[])
	{
		Th9 ob = new Th9();
		Thread t1 = new Thread(ob);
		Thread t2 = new Thread(ob);
		t1.start();
		t2.start();

		System.out.println("Both the threads are over");
	}
}


In the above code "Both the threads are over" will not be displayed in the end because it is a statement of main. It is because as we know, main thread completes first and user defined thread are continue, they are taken care by JVM.
If we want that "Both the threads are over" should be displayed at the end, we have to make sure that main thread will complete only after the completion of "t1" and "t2".

Solution is "join()" method.

join() method

join method makes caller thread (main thread) to wait for called thread (t1 and t2) to complete.

how join works?


public class Th9_a implements Runnable
{
	public void run()
	{
		synchronized(this)
		{
			for(int i=0; i<5; i++)
			{
				System.out.println("Hello" + i);
			}
		}
	}
	public static void main(String args[])
	{
		Th9 ob = new Th9();
		Th9 ob1 = new Th9();
		Thread t1 = new Thread(ob);
		Thread t2 = new Thread(ob1);
		t1.start();
		t2.start();
		try
		{
			t1.join();
			t2.join();
		}
		catch(InterruptedException e)
		{
		}
		System.out.println("Both the threads are over");
	}
}

In the above code, when main() function calls "t1.join()" for example, it says "join me at your end".
Since main() is calling "t1.join()" and "t2.join()", it is added to the end of both t1 and t2. That's why now the statement "Both the threads are over" is getting executed at the end.



Whenever thread is in a blocked state ie.due to sleep, join or wait methods, it can get interrupted by other threads. Whenever blocked thread gets interrupted, it raises "InterruptedException".
 But this can not be predictable, hence java enforces you to either handle or declare InterruptedException whenever you invoke the above methods.

Thread states

	born
	runnable
	running
	blocked
	dead


User threads and Daemon threads

User threads
	user defined threads
	main thread

Daemon thread
	e.g. garbage collection thread (low priority thread)

Daemon threads are the threads which are at the mercy of user thread/s. Their only purpose is to serve user defined thread/s. When there is no user thread alive, Daemon thread will die.


Example of Garbage Collection Thread


public class Sample
{

	public static void main(String[] args) {
		Sample s1 = new Sample();
		s1 = null;
		System.gc();
		try
		{
			Thread.sleep(100);
		}
		catch(InterruptedException ie)
		{
			ie.printStackTrace();
		}

		//Runtime.getRuntime().gc();
		System.out.println("Done By\t" + Thread.currentThread().getName());

	}

	protected void finalize() throws Throwable
	{
		System.out.println("inside finalized method");
		System.out.println(Thread.currentThread());
		System.out.println(Thread.currentThread().isDaemon());

	}

}




output:


inside finalized method
Thread[Finalizer,8,system]
true
Done by main


Difference between

	System.gc() and Runtime.getRuntime.gc()

inside "System" class we have following code:


public static void gc()
{
        Runtime.getRuntime().gc();
}
